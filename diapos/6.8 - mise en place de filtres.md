# Mise en place de filtres

----

## La notion de filtre

- objet Java qui peut modifier les en-têtes et le contenu d'une requête ou d'une réponse HTTP
- permet de faire des actions systématiques avant chaque requête
- fonctionnement :
	- arrivée de la requête du client sur le serveur
	- passage dans la chaîne des filtres dans l'ordre défini
	- passage dans la servlet correspondant à la requête
	- passage dans les filtres dans le sens inverse du premier passage
	- envoi de la réponse au client


----

## Exemple de filtre simple

```java
import javax.servlet.Filter;

@Component // définition du filtre comme composant Spring
@Order(2) // définition de l'ordre du filtre dans la chaine des filtres
public class SimpleFilter implements Filter {	
	private static final Logger log = LoggerFactory.getLogger(SimpleFilter.class);

	@Override
	public void doFilter (ServletRequest request, ServletResponse response, FilterChain chain)
			throws IOException, ServletException {

		HttpServletRequest req = (HttpServletRequest) request;
		log.info("Début de la requête " + req.getRequestURI());

		chain.doFilter(request, response);

		log.info("Fin de la requête " + req.getRequestURI());
	}
}
```

----

## Exemple de filtre uniquement sur certaines requêtes (1)

```java
// on ne définit plus la classe comme composant Spring
public class PartialFilter implements Filter {

	private static final Logger log = LoggerFactory.getLogger(PartialFilter.class);
	
	@Override
	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
			throws IOException, ServletException {
		HttpServletRequest req = (HttpServletRequest) request;
		HttpServletResponse res = (HttpServletResponse) response;
		log.info("Filtre uniquement pour les requêtes sur le vin (requête) : "
				+ req.getMethod() + ", " + req.getRequestURI());

		chain.doFilter(request, response);

		log.info("Filtre uniquement pour les requêtes sur le vin (Content-Type de la réponse) : "
				+ res.getContentType());
		}
}

```

----

## Exemple de filtre uniquement sur certaines requêtes (2)

- création d'une classe pour configurer nos filtres avec l'annotation `@Configuration`
- création d'un **FilterRegistrationBean** pour le filtre que l'on souhaite configurer avec l'annotation `@Bean`

```java
@Configuration
public class FilterConfig {
	@Bean
	public FilterRegistrationBean<PartialFilter> loggingFilter(){
		FilterRegistrationBean<PartialFilter> registrationBean = new FilterRegistrationBean<>();		
		registrationBean.setFilter(new PartialFilter());
		registrationBean.addUrlPatterns("/vin/*"); // passage dans le filtre uniquement sur les URL /vin
		registrationBean.setOrder(3); // définition de l'ordre du filtre	
		return registrationBean;    
	}
}
```

----

## Compresser la réponse (1)

Lorsque la réponse HTTP est grosse, il est possible de compresser pour alléger le transfert sur réseau. Charge au client de la décompresser (le navigateur sait le faire tout seul)
- pour compresser une réponse HTTP, il faut que le client soit d'accord et que le header **Accept-Encoding: gzip** soit présent dans la requête
- si la réponse est compressée, il y aura le header **Content-Encoding: gzip**

Utilisation d'une bibliothèque [Ziplet](https://github.com/ziplet/ziplet) qui créer un filtre pour zipper la réponse

----

## Compresser la réponse (2)

Ajouter la dépendance suivante, et créer un package **config** et créer la classe ZipletConfig

```xml
<dependency>
	<groupId>com.github.ziplet</groupId>
	<artifactId>ziplet</artifactId>
	<version>2.3.0</version>
</dependency>
```
```java
// Ajout d'un FilterRegistrationBean pour configurer le filtre de compression de la réponse
	// Configuration du filtre de compression de la réponse
	@Bean
	public FilterRegistrationBean<CompressingFilter> compressingFilter(){
		FilterRegistrationBean<CompressingFilter> registrationBean = new FilterRegistrationBean<>();
		registrationBean.setFilter(new CompressingFilter());
		registrationBean.setOrder(1);
		return registrationBean;
	}
//	@Bean
//	public Filter compressFilter() {
//	    return new CompressingFilter();
//	}
```

----

## CORS : Cross-origin resource sharing (1)

- contrainte de sécurité du navigateur qui empêche les requêtes HTTP provenant d'un domaine différent que celui dont vient le script
- pour permettre les requêtes multi-origines, il faut ajouter des en-têtes CORS
- configuration côté serveur avec un filtre Java par exemple
- headers de la requête
	- **Access-Control-Request-Headers**: authorization
	- **Access-Control-Request-Method**: GET
- headers dans la réponse :
	- **Access-Control-Allow-Credentials**: true
	- **Access-Control-Allow-Headers**: authorization
	- **Access-Control-Allow-Methods**: GET
	- **Access-Control-Allow-Origin**: url du serveur
	- **Access-Control-Max-Age**: 3600

----

## CORS : Cross-origin resource sharing (2)

ajout d'un filtre pour gérer le CORS

```java
// Congifuration du filtre pour la gestion du CORS
@Bean
public FilterRegistrationBean<CorsFilter> corsFilter() {
	UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
	CorsConfiguration config = new CorsConfiguration();
	config.setAllowCredentials(true);
	config.addAllowedOrigin("*");
	config.addAllowedHeader("*");
	config.addAllowedMethod("*");
	config.setMaxAge(3600L);
	source.registerCorsConfiguration("/**", config);
    FilterRegistrationBean<CorsFilter> registrationBean = new FilterRegistrationBean<>();
    registrationBean.setFilter(new CorsFilter(source));
    registrationBean.setOrder(0);
	return registrationBean;
}
```
