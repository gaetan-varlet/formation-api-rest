# Les tests avec Cucumber

----

## Bibliothèques

```xml
<cucumber.version>7.11.1</cucumber.version>
```
```xml
<dependency>
	<groupId>org.junit.platform</groupId>
	<artifactId>junit-platform-suite</artifactId>
	<scope>test</scope>
</dependency>
<dependency>
	<groupId>io.cucumber</groupId>
	<artifactId>cucumber-spring</artifactId>
	<version>${cucumber.version}</version>
	<scope>test</scope>
</dependency>
<dependency>
	<groupId>io.cucumber</groupId>
	<artifactId>cucumber-java</artifactId>
	<version>${cucumber.version}</version>
	<scope>test</scope>
</dependency>
<dependency>
	<groupId>io.cucumber</groupId>
	<artifactId>cucumber-junit-platform-engine</artifactId>
	<version>${cucumber.version}</version>
	<scope>test</scope>
</dependency>
```

----

## Configuration 

```java
@SpringBootTest
@TestPropertySource(properties = {
        "spring.datasource.driver-class-name=org.h2.Driver",
        "spring.datasource.url=jdbc:h2:mem:testdb"
})
@CucumberContextConfiguration
public class SpringBootIT {}
```
```java
import static io.cucumber.junit.platform.engine.Constants.GLUE_PROPERTY_NAME;
import static io.cucumber.junit.platform.engine.Constants.PLUGIN_PROPERTY_NAME;

// utilisation la plateforme Junit pour exécuter nos scénarios
@Suite
@IncludeEngines("cucumber")
// les fichiers .feature sont dans le dossier features des ressources de tests
@SelectClasspathResource("features")
// les Steps et la config Spring seront à chercher dans le package indiqué ici
@ConfigurationParameter(key = GLUE_PROPERTY_NAME, value = "fr.insee.formationapirest")
@ConfigurationParameter(key = PLUGIN_PROPERTY_NAME, value = "pretty, json:target/cucumber.json, html:target/reports/cucumber/rapport.html,"
                + " usage:target/usage.jsonx, junit:target/junit.xml")
public class CucumberRunnerIT {
}
```

----

## Création de features

```gherkin
Feature: Obtenir les vins

    Background: création d'un jeu de données pour vérifier les données renvoyées
        Given des vins avec les attributs suivants
            | chateau   | appellation  | prix |
            | Château 1 | Saint-Julien | 10.5 |
            | Château 2 | Pomerol      | 25   |

    Scenario: obtenir tous les vins quand il y a un vin en base
        When je récupère tous les vins
        Then le nombre de vins est 2
        Then le vin du chateau "Château 1" de l'appellation "Saint-Julien" à 10.5€ est renvoyé
        Then le vin du chateau "Château 2" de l'appellation "Pomerol" à 25€ est renvoyé
	
	Scenario Outline: obtenir tous les vins d'une appellation existante
        When je récupère tous les vins de l'appellation "<appellation>"
        Then le nombre de vins est <nombre_vins>
        Then le vin du chateau "<chateau>" de l'appellation "<appellation>" à <prix>€ est renvoyé
        Examples:
            | appellation  | nombre_vins | chateau   | prix |
            | Pomerol      | 1           | Château 2 | 25   |
            | Saint-Julien | 1           | Château 1 | 10.5 |
```

----

## Création d'une glue (1)

```java
@RequiredArgsConstructor
public class VinGlue {
    private final VinRepository vinRepository;
    private List<Vin> vins;

    @Before
    public void clearDatabase() {
        vinRepository.deleteAllInBatchtoSave();
    }

    @Given("des vins avec les attributs suivants")
    public void givenVins(DataTable dataTable) {
        List<Map<String, String>> dataAsMaps = dataTable.asMaps();
        List<Vin> toSave = dataAsMaps.stream().map(this::transformMapToVin).toList();
        vinRepository.saveAll(toSave);
    }

    private Vin transformMapToVin(Map<String, String> line) {
        Vin v = new Vin();
        v.setChateau(line.get("chateau"));
        v.setAppellation(line.get("appellation"));
        v.setPrix(Double.valueOf(line.get("prix")));
        return v;
    }
```

----

## Création d'une glue (2)

```java
 	@When("je récupère tous les vins")
    public void getVins() {
        vins = vinService.findAll(null);
    }

    @When("je récupère tous les vins de l'appellation {string}")
    public void getVinsApp(String app) {
        vins = vinService.findAll(app);
    }

    @Then("le nombre de vins est {int}")
    public void nbVins(int nbExcepted) {
        assertThat(vins).hasSize(nbExcepted);
    }

    @Then("le vin du chateau {string} de l'appellation {string} à {double}€ est renvoyé")
    public void verifVins(String chateau, String appellation, Double prix) {
        List<Vin> vinsFiltres = vins.stream().filter(v -> v.getChateau().equals(chateau)).toList();
        assertThat(vinsFiltres).hasSize(1);
        assertThat(vinsFiltres.get(0).getChateau()).isEqualTo(chateau);
        assertThat(vinsFiltres.get(0).getAppellation()).isEqualTo(appellation);
        assertThat(vinsFiltres.get(0).getPrix()).isEqualTo(prix);
    }
}
```


----

## Ajout d'une bibliothèque pour générer des INSERT

```xml
<dependency>
	<groupId>com.ninja-squad</groupId>
	<artifactId>DbSetup</artifactId>
	<version>2.1.0</version>
</dependency>
```

----

## Méthode générique pour faire des INSERT (1)

```java
@Slf4j
@RequiredArgsConstructor
@Component
public class SaveData {

    private final DataSource dataSource;

    public void insertInTable(String nomTable, List<Map<String, String>> data) {
        log.info("Chargement de la table {}", nomTable);
        if (nomTable == null) {
            throw new IllegalArgumentException("Il faut renseigner la table à peupler");
        }
        for (Map<String, String> ligne : data) {
            if (ligne.entrySet().stream().noneMatch(e -> !StringUtils.isEmpty(e.getValue()))) {
				// Toutes les colonnes de la ligne sont vides, on n'insère rien
                return; 
            }
```

----

## Méthode générique pour faire des INSERT (2)

```java
 RowBuilder rowBuilder = Operations.insertInto(nomTable).row();
            for (Entry<String, String> attribut : ligne.entrySet()) {
                if (!StringUtils.isEmpty(attribut.getValue())) {
                    if (Pattern.compile("\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}").matcher(attribut.getValue())
                            .matches()) {
                        rowBuilder = rowBuilder.column(attribut.getKey(), LocalDateTime.parse(attribut.getValue(),
                                DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")));
                    } else if (Pattern.compile("\\d{4}-\\d{2}-\\d{2}").matcher(attribut.getValue()).matches()) {
                        rowBuilder = rowBuilder.column(attribut.getKey(),
                                LocalDate.parse(attribut.getValue(), DateTimeFormatter.ofPattern("yyyy-MM-dd")));
                    } else {
                        rowBuilder = rowBuilder.column(attribut.getKey(), attribut.getValue());
                    }
                }
            }
            Insert insert = rowBuilder.end().build();
            DbSetup dbSetup = new DbSetup(new DataSourceDestination(dataSource), insert);
            dbSetup.launch();
        }
    }
}
```

----

## Contrôle des droits d'accès

TODO

