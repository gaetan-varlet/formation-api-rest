# Les tests avec Cucumber

----

## Bibliothèques

```xml
<properties>
	<cucumber.version>7.11.1</cucumber.version>
</properties>
```
```xml
<dependency>
	<groupId>org.junit.platform</groupId>
	<artifactId>junit-platform-suite</artifactId>
	<scope>test</scope>
</dependency>
<dependency>
	<groupId>io.cucumber</groupId>
	<artifactId>cucumber-spring</artifactId>
	<version>${cucumber.version}</version>
	<scope>test</scope>
</dependency>
<dependency>
	<groupId>io.cucumber</groupId>
	<artifactId>cucumber-java</artifactId>
	<version>${cucumber.version}</version>
	<scope>test</scope>
</dependency>
<dependency>
	<groupId>io.cucumber</groupId>
	<artifactId>cucumber-junit-platform-engine</artifactId>
	<version>${cucumber.version}</version>
	<scope>test</scope>
</dependency>
```

----

## Configuration 

```java
@SpringBootTest
@TestPropertySource(properties = {
        "spring.datasource.driver-class-name=org.h2.Driver",
        "spring.datasource.url=jdbc:h2:mem:testdb"
})
@CucumberContextConfiguration
public class SpringBootIT {}
```
```java
import static io.cucumber.junit.platform.engine.Constants.GLUE_PROPERTY_NAME;
import static io.cucumber.junit.platform.engine.Constants.PLUGIN_PROPERTY_NAME;

// utilisation la plateforme Junit pour exécuter nos scénarios
@Suite
@IncludeEngines("cucumber")
// les fichiers .feature sont dans le dossier features des ressources de tests
@SelectClasspathResource("features")
// les Steps et la config Spring seront à chercher dans le package indiqué ici
@ConfigurationParameter(key = GLUE_PROPERTY_NAME, value = "fr.insee.formationapirest")
@ConfigurationParameter(key = PLUGIN_PROPERTY_NAME, value = "pretty, json:target/cucumber.json, html:target/reports/cucumber/rapport.html,"
                + " usage:target/usage.jsonx, junit:target/junit.xml")
public class CucumberRunnerIT {
}
```

----

## Création de features

```gherkin
Feature: Obtenir les vins

    Background: création d'un jeu de données pour vérifier les données renvoyées
        Given des vins avec les attributs suivants
            | chateau   | appellation  | prix |
            | Château 1 | Saint-Julien | 10.5 |
            | Château 2 | Pomerol      | 25   |

    Scenario: obtenir tous les vins quand il y a un vin en base
        When je récupère tous les vins
        Then le nombre de vins est 2
        Then le vin du chateau "Château 1" de l'appellation "Saint-Julien" à 10.5€ est renvoyé
        Then le vin du chateau "Château 2" de l'appellation "Pomerol" à 25€ est renvoyé
	
	Scenario Outline: obtenir tous les vins d'une appellation existante
        When je récupère tous les vins de l'appellation "<appellation>"
        Then le nombre de vins est <nombre_vins>
        Then le vin du chateau "<chateau>" de l'appellation "<appellation>" à <prix>€ est renvoyé
        Examples:
            | appellation  | nombre_vins | chateau   | prix |
            | Pomerol      | 1           | Château 2 | 25   |
            | Saint-Julien | 1           | Château 1 | 10.5 |
```

----

## Création d'une glue

TODO


----

## Ajout d'une bibliothèque pour générer des INSERT

```xml
<dependency>
	<groupId>com.ninja-squad</groupId>
	<artifactId>DbSetup</artifactId>
	<version>2.1.0</version>
</dependency>
```

----

## Méthide générique pour faire des INSERT

```java
@Slf4j
@RequiredArgsConstructor
@Component
public class SaveData {

    private final DataSource dataSource;

    public void insertInTable(String nomTable, List<Map<String, String>> data) {
        log.info("Chargement de la table {}", nomTable);
        if (nomTable == null) {
            throw new IllegalArgumentException("Il faut renseigner la table à peupler");
        }
        for (Map<String, String> ligne : data) {
            if (ligne.entrySet().stream().noneMatch(e -> !StringUtils.isEmpty(e.getValue()))) {
                // Toutes les colonnes de la ligne sont vides, on n'insère rien
                return;
            }
            RowBuilder rowBuilder = Operations.insertInto(nomTable).row();
            for (Entry<String, String> attribut : ligne.entrySet()) {
                if (!StringUtils.isEmpty(attribut.getValue())) {
                    if (Pattern.compile("\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}").matcher(attribut.getValue())
                            .matches()) {
                        rowBuilder = rowBuilder.column(attribut.getKey(), LocalDateTime.parse(attribut.getValue(),
                                DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")));
                    } else if (Pattern.compile("\\d{4}-\\d{2}-\\d{2}").matcher(attribut.getValue()).matches()) {
                        rowBuilder = rowBuilder.column(attribut.getKey(),
                                LocalDate.parse(attribut.getValue(), DateTimeFormatter.ofPattern("yyyy-MM-dd")));
                    } else {
                        rowBuilder = rowBuilder.column(attribut.getKey(), attribut.getValue());
                    }
                }
            }
            Insert insert = rowBuilder.end().build();
            DbSetup dbSetup = new DbSetup(new DataSourceDestination(dataSource), insert);
            dbSetup.launch();
        }
    }
}
```

----

## Contrôle des droits d'accès

TODO

