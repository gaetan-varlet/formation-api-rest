# Les tests avec Cucumber

----

## Principes

- framework de tests, pour l’implémentation de scénarios de type BDD (Behavior-Driven-Development)
- utilisation du langage **Gherkin**, proche du langage humain et compréhensible par les non informaticiens, pour spécifier les comportements logiciels attendus
- écriture d'un code de **glue** pour faire le lien entre les spécifications en *Gherkin* et le code Java
- possibilité de faire des tests unitaires ou des tests d'intégration
- permet d'avoir une documentation vivante et à jour (**living documentation**) grâce à nos tests

----

## Living Documentation

<img src="diapos/images/cucumber-report.png" alt="Rapport Cucumber" width="600" >

----

## Bibliothèques

```xml
<cucumber.version>7.11.1</cucumber.version>
```
```xml
<dependency>
	<groupId>org.junit.platform</groupId>
	<artifactId>junit-platform-suite</artifactId>
	<scope>test</scope>
</dependency>
<dependency>
	<groupId>io.cucumber</groupId>
	<artifactId>cucumber-spring</artifactId>
	<version>${cucumber.version}</version>
	<scope>test</scope>
</dependency>
<dependency>
	<groupId>io.cucumber</groupId>
	<artifactId>cucumber-java</artifactId>
	<version>${cucumber.version}</version>
	<scope>test</scope>
</dependency>
<dependency>
	<groupId>io.cucumber</groupId>
	<artifactId>cucumber-junit-platform-engine</artifactId>
	<version>${cucumber.version}</version>
	<scope>test</scope>
</dependency>
```

----

## Configuration 

```java
@SpringBootTest
// permet de faire des requêtes HTTP avec MockMvc
@AutoConfigureMockMvc
@TestPropertySource(properties = {
        "spring.datasource.driver-class-name=org.h2.Driver",
        "spring.datasource.url=jdbc:h2:mem:testdb"
})
@CucumberContextConfiguration
public class SpringBootIT {}
```
```java
import static io.cucumber.junit.platform.engine.Constants.GLUE_PROPERTY_NAME;
import static io.cucumber.junit.platform.engine.Constants.PLUGIN_PROPERTY_NAME;

// utilisation la plateforme Junit pour exécuter nos scénarios
@Suite
@IncludeEngines("cucumber")
// les fichiers .feature sont dans le dossier features des ressources de tests
@SelectClasspathResource("features")
// les Steps et la config Spring seront à chercher dans le package indiqué ici
@ConfigurationParameter(key = GLUE_PROPERTY_NAME, value = "fr.insee.formationapirest")
@ConfigurationParameter(key = PLUGIN_PROPERTY_NAME, value = "pretty, json:target/cucumber.json, html:target/reports/cucumber/rapport.html,"
                + " usage:target/usage.jsonx, junit:target/junit.xml")
public class CucumberRunnerIT {
}
```

----

## Création de features

```gherkin
Feature: Obtenir les vins

    Background: création d'un jeu de données pour vérifier les données renvoyées
        Given des vins avec les attributs suivants
            | chateau   | appellation  | prix |
            | Château 1 | Saint-Julien | 10.5 |
            | Château 2 | Pomerol      | 25   |
            | Château 3 | Pomerol      | 30   |

    Scenario: obtenir tous les vins quand il y a un vin en base
        When je récupère tous les vins
        Then le nombre de vins est 3
        Then le vin du chateau "Château 1" de l'appellation "Saint-Julien" à 10.5€ est renvoyé
        Then le vin du chateau "Château 2" de l'appellation "Pomerol" à 25€ est renvoyé
        Then le vin du chateau "Château 3" de l'appellation "Pomerol" à 30€ est renvoyé

    Scenario Outline: obtenir tous les vins d'une appellation existante
        When je récupère tous les vins de l'appellation "<appellation>"
        Then le nombre de vins est <nombre_vins>
        Then le vin du chateau "<chateau>" de l'appellation "<appellation>" à <prix>€ est renvoyé
        Examples: appellation existante
            | appellation  | nombre_vins | chateau   | prix |
            | Saint-Julien | 1           | Château 1 | 10.5 |
            | Pomerol      | 2           | Château 2 | 25   |
            | Pomerol      | 2           | Château 3 | 30   |
```

----

## Création d'une glue (1)

```java
import static org.assertj.core.api.Assertions.assertThat;

@RequiredArgsConstructor
public class VinGlue {
    private final VinRepository vinRepository;
    private List<Vin> vins;

    @Before
    public void clearDatabase() {
        vinRepository.deleteAllInBatch();
    }

    @Given("des vins avec les attributs suivants")
    public void givenVins(DataTable dataTable) {
        List<Map<String, String>> dataAsMaps = dataTable.asMaps();
        List<Vin> toSave = dataAsMaps.stream().map(this::transformMapToVin).toList();
        vinRepository.saveAll(toSave);
    }

    private Vin transformMapToVin(Map<String, String> line) {
        Vin v = new Vin();
        v.setChateau(line.get("chateau"));
        v.setAppellation(line.get("appellation"));
        v.setPrix(Double.valueOf(line.get("prix")));
        return v;
    }
```

----

## Création d'une glue (2)

```java
 	@When("je récupère tous les vins")
    public void getVins() {
        vins = vinService.findAll(null);
    }

    @When("je récupère tous les vins de l'appellation {string}")
    public void getVinsApp(String app) {
        vins = vinService.findAll(app);
    }

    @Then("le nombre de vins est {int}")
    public void nbVins(int nbExcepted) {
        assertThat(vins).hasSize(nbExcepted);
    }

    @Then("le vin du chateau {string} de l'appellation {string} à {double}€ est renvoyé")
    public void verifVins(String chateau, String appellation, Double prix) {
        List<Vin> vinsFiltres = vins.stream()
                .filter(v -> v.getChateau().equals(chateau) && v.getAppellation().equals(appellation)).toList();
        assertThat(vinsFiltres).hasSize(1);
        assertThat(vinsFiltres.get(0).getPrix()).isEqualTo(prix);
    }
}
```

----

## Features pour créer des vins

```gherkin
Feature: Créer des vins

    Scenario Outline: créer un vin avec des informations erronées (<testCase>)
        Given je veux créer un vin avec les attributs suivants
            | chateau   | appellation   | prix   |
            | <chateau> | <appellation> | <prix> |
        When je récupère tous les vins
        Then le nombre de vins est 0
        Then j'ai le message d'erreur suivant "<message>"
        Examples:
            | testCase                     | chateau                                             | appellation | prix | message                                                                                                                                    |
            | nom de château trop long     | 123456789012345678901234567890123456789012345678901 | toto        | 5    | le vin renseigné (Vin [id=null, chateau=123456789012345678901234567890123456789012345678901, appellation=toto, prix=5.0]) n'est pas valide |
            | nom de château non renseigné |                                                     | toto        | 5    | le vin renseigné (Vin [id=null, chateau=null, appellation=toto, prix=5.0]) n'est pas valide                                                |

    Scenario Outline: créer un vin avec des informations justes
        Given je veux créer un vin avec les attributs suivants
            | chateau   | appellation   | prix   |
            | <chateau> | <appellation> | <prix> |
        When je récupère tous les vins
        Then le nombre de vins est 1
        Then le vin du chateau "<chateau>" de l'appellation "<appellation>" à <prix>€ est renvoyé
        Examples:
            | chateau   | appellation | prix |
            | Chateau 1 | app1        | 5    |
            | Chateau 2 | toto        | 1.23 |
```

----

## Glue associée à la création

```java
    private final VinService vinService;
    private List<Vin> vins;
    private String exception;

	@Given("je veux créer un vin avec les attributs suivants")
    public void saveVins(DataTable dataTable) {
        try {
            List<Map<String, String>> line = dataTable.asMaps();
            vinService.add(transformMapToVin(line.get(0)));
            exception = null;
        } catch (Exception e) {
            exception = e.getMessage();
        }
    }

	@Then("j'ai le message d'erreur suivant {string}")
    public void verifierErreur(String expectedError) {
        assertThat(exception).isEqualTo(expectedError);
    }
```


----

## Contrôle des droits d'accès : Feature

```gherkin
Feature: Tester les droits d'accès

    Scenario: impossibilité d'accéder au endpoint /hello-secured sans jeton
        When je fais une requête HTTP en GET sur l'url "/hello-secured"
        Then j'obtiens un code retour HTTP 401

    @WithRoleToto
    Scenario: impossibilité d'accéder au endpoint /hello-secured avec un mauvais rôle
        When je fais une requête HTTP en GET sur l'url "/hello-secured"
        Then j'obtiens un code retour HTTP 403

    @WithRoleAdmin
    Scenario: impossibilité d'accéder au endpoint /hello-secured avec le rôle admin
        When je fais une requête HTTP en GET sur l'url "/hello-secured"
        Then j'obtiens un code retour HTTP 200
```

----

## Contrôle des droits d'accès : Glue

```java
@RequiredArgsConstructor
public class SecurityGlue {

    private final MockMvc mockMvc;

    private String rolePrefix = "ROLE_";
    private ResultActions result;

    @Before("@WithRoleAdmin")
    public void setupRoleAdmin() {
        SecurityContextHolder.getContext().setAuthentication(new UsernamePasswordAuthenticationToken("admin", "N/A",
                AuthorityUtils.createAuthorityList(rolePrefix + "ADMIN_TOUCAN")));
    }

    @When("je fais une requête HTTP en GET sur l'url {string}")
    public void requeteGet(String url) throws Exception {
        result = mockMvc.perform(MockMvcRequestBuilders.get(url));
    }

    @Then("j'obtiens un code retour HTTP {int}")
    public void testCodeReponse(int codeReponse) throws Exception {
        result.andExpect(MockMvcResultMatchers.status().is(codeReponse));
    }

}
```

----

## Ajout d'une bibliothèque pour générer des INSERT

```xml
<dependency>
	<groupId>com.ninja-squad</groupId>
	<artifactId>DbSetup</artifactId>
	<version>2.1.0</version>
</dependency>
```

----

## Méthode générique pour faire des INSERT (1)

```java
@Slf4j
@RequiredArgsConstructor
@Component
public class SaveData {

    private final DataSource dataSource;

    public void insertInTable(String nomTable, List<Map<String, String>> data) {
        log.info("Chargement de la table {}", nomTable);
        if (nomTable == null) {
            throw new IllegalArgumentException("Il faut renseigner la table à peupler");
        }
        for (Map<String, String> ligne : data) {
            if (ligne.entrySet().stream().noneMatch(e -> !StringUtils.isEmpty(e.getValue()))) {
				// Toutes les colonnes de la ligne sont vides, on n'insère rien
                return; 
            }
```

----

## Méthode générique pour faire des INSERT (2)

```java
 RowBuilder rowBuilder = Operations.insertInto(nomTable).row();
            for (Entry<String, String> attribut : ligne.entrySet()) {
                if (!StringUtils.isEmpty(attribut.getValue())) {
                    if (Pattern.compile("\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}").matcher(attribut.getValue())
                            .matches()) {
                        rowBuilder = rowBuilder.column(attribut.getKey(), LocalDateTime.parse(attribut.getValue(),
                                DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")));
                    } else if (Pattern.compile("\\d{4}-\\d{2}-\\d{2}").matcher(attribut.getValue()).matches()) {
                        rowBuilder = rowBuilder.column(attribut.getKey(),
                                LocalDate.parse(attribut.getValue(), DateTimeFormatter.ofPattern("yyyy-MM-dd")));
                    } else {
                        rowBuilder = rowBuilder.column(attribut.getKey(), attribut.getValue());
                    }
                }
            }
            Insert insert = rowBuilder.end().build();
            DbSetup dbSetup = new DbSetup(new DataSourceDestination(dataSource), insert);
            dbSetup.launch();
        }
    }
}
```
